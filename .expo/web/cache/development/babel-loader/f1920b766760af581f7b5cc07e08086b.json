{"ast":null,"code":"import { connect as connectX } from 'react-redux';\nimport { RootStore } from \"./config\";\nimport { valueExtractor } from \"./depth\";\nvar errors = {\n  xSetState: 'Provided state is not an object',\n  getStateForKey: 'getStateForKey: Giving key must be string!',\n  connectWrapped: 'WrappedComponent is required',\n  requiredKeysArray: 'required keys is not an Array',\n  requiredKeysStrings: 'all required keys should be strings'\n};\n\nvar xResetState = function xResetState() {\n  return setStateForKey('xResetState', null);\n};\n\nvar xSetState = function xSetState(state) {\n  if (typeof state !== 'object') {\n    console.warn(errors.xSetState);\n    return;\n  }\n\n  for (var key in state) {\n    setStateForKey(key, state[key]);\n  }\n};\n\nvar getStateForKey = function getStateForKey(key) {\n  var fallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n  if (typeof key !== 'string') {\n    console.warn(errors.getStateForKey);\n    return null;\n  }\n\n  var _RootStore$getState = RootStore.getState(),\n      RN = _RootStore$getState.RN;\n\n  var value = valueExtractor(RN, key);\n  return value || fallback;\n};\n\nvar setStateForKey = function setStateForKey(key, state) {\n  RootStore.dispatch({\n    type: key,\n    payload: state\n  });\n};\n\nvar connect = function connect(WrappedComponent) {\n  var requiredKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var deepKeyReplacer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '_';\n\n  if (typeof WrappedComponent === 'undefined') {\n    throw Error(errors.connectWrapped);\n  }\n\n  var errorTemplate = function errorTemplate(reason) {\n    return \"ReactNativeRedux.connect\\nFailed to connect \\\"\" + WrappedComponent.name + \"\\\"\\nReason: \" + reason;\n  };\n\n  if (!Array.isArray(requiredKeys)) {\n    throw Error(errorTemplate(errors.requiredKeysArray));\n  }\n\n  var allStrings = requiredKeys.every(function (key) {\n    return typeof key === 'string';\n  });\n\n  if (!allStrings) {\n    throw Error(errorTemplate(errors.requiredKeysStrings));\n  }\n\n  var mapStateToProps = function mapStateToProps(_ref) {\n    var RN = _ref.RN;\n    var propsToConnect = {};\n\n    if (requiredKeys.length === 0) {\n      for (var key in RN) {\n        if (key !== 'didInit') {\n          propsToConnect[key] = RN[key];\n        }\n      }\n\n      return propsToConnect;\n    }\n\n    for (var _key of requiredKeys) {\n      var isDeepKey = _key.includes('.');\n\n      var propKey = isDeepKey ? _key.split('.').join(deepKeyReplacer) : _key;\n      propsToConnect[propKey] = valueExtractor(RN, _key);\n    }\n\n    return propsToConnect;\n  };\n\n  return connectX(mapStateToProps, {})(WrappedComponent);\n};\n\nexport { connect, xSetState, xResetState, setStateForKey, getStateForKey };","map":{"version":3,"names":["connect","connectX","RootStore","valueExtractor","errors","xSetState","getStateForKey","connectWrapped","requiredKeysArray","requiredKeysStrings","xResetState","setStateForKey","state","console","warn","key","fallback","getState","RN","value","dispatch","type","payload","WrappedComponent","requiredKeys","deepKeyReplacer","Error","errorTemplate","reason","name","Array","isArray","allStrings","every","mapStateToProps","propsToConnect","length","isDeepKey","includes","propKey","split","join"],"sources":["C:/Users/cjchu/AwesomeProject/node_modules/react-native-redux/src/methods.tsx"],"sourcesContent":["import { connect as connectX } from 'react-redux';\nimport { RootStore } from './config';\nimport { valueExtractor } from './depth';\n\nconst errors = {\n    xSetState: 'Provided state is not an object',\n    getStateForKey: 'getStateForKey: Giving key must be string!',\n    connectWrapped: 'WrappedComponent is required',\n    requiredKeysArray: 'required keys is not an Array',\n    requiredKeysStrings: 'all required keys should be strings',\n};\n\n/**\n * Reset State - Clears stored state tree.\n */\nconst xResetState = () => setStateForKey('xResetState', null);\n/**\n * X Set State\n * @param {object} state\n */\nconst xSetState = (state: object) => {\n    if (typeof state !== 'object') {\n        console.warn(errors.xSetState);\n        return;\n    }\n    for (const key in state) { setStateForKey(key, state[key]); }\n};\n\n/**\n    * Get State for Keys and subkeys (\"key.subkey\")\n    * @example\n    * // Get userData Object (key)\n    * const userData = getStateForKey('userData')\n    *\n    * // Get user's name from userData Object (Subkey)\n    * const userName = getStateForKey('userData.name')\n    * @param {string} key Key for required state\n */\nconst getStateForKey = (key: string, fallback = null) => {\n    if (typeof key !== 'string') {\n        console.warn(errors.getStateForKey);\n        return null;\n    }\n    const { RN } = RootStore.getState();\n    const value = valueExtractor(RN, key);\n    return value || fallback;\n};\n\n/**\n * Similar to xSetState, plus it can be used to set deep state\n */\nconst setStateForKey = (key: string, state: any) => {\n    RootStore.dispatch({ type: key, payload: state });\n};\n\n/**\n * React Component Connector\n * @param WrappedComponent Class Component\n * @param {Array<string>} requiredKeys Array Of required keys to be connected.\n */\nconst connect = (\n    WrappedComponent,\n    requiredKeys: Array<string> = [],\n    deepKeyReplacer: string = '_'\n) => {\n\n    if (typeof WrappedComponent === 'undefined') { throw Error(errors.connectWrapped); }\n\n    const errorTemplate = (reason: string) =>\n        `ReactNativeRedux.connect\\nFailed to connect \"${WrappedComponent.name}\"\\nReason: ${reason}`;\n\n    if (!Array.isArray(requiredKeys)) { throw Error(errorTemplate(errors.requiredKeysArray)); }\n\n    const allStrings = requiredKeys.every((key) => typeof key === 'string');\n    if (!allStrings) {\n        throw Error(errorTemplate(errors.requiredKeysStrings));\n    }\n    const mapStateToProps = ({ RN }) => {\n        const propsToConnect = {};\n        if (requiredKeys.length === 0) {\n            for (const key in RN) {\n                if (key !== 'didInit') { propsToConnect[key] = RN[key]; }\n            }\n            return propsToConnect;\n        }\n        for (const key of requiredKeys) {\n            const isDeepKey = key.includes('.');\n            const propKey = isDeepKey ? key.split('.').join(deepKeyReplacer) : key;\n            propsToConnect[propKey] = valueExtractor(RN, key);\n        }\n        return propsToConnect;\n    };\n    return connectX(mapStateToProps, {})(WrappedComponent);\n};\n\n\nexport {\n    connect,\n    xSetState, xResetState,\n    setStateForKey, getStateForKey,\n};\n"],"mappings":"AAAA,SAASA,OAAO,IAAIC,QAApB,QAAoC,aAApC;AACA,SAASC,SAAT;AACA,SAASC,cAAT;AAEA,IAAMC,MAAM,GAAG;EACXC,SAAS,EAAE,iCADA;EAEXC,cAAc,EAAE,4CAFL;EAGXC,cAAc,EAAE,8BAHL;EAIXC,iBAAiB,EAAE,+BAJR;EAKXC,mBAAmB,EAAE;AALV,CAAf;;AAWA,IAAMC,WAAW,GAAG,SAAdA,WAAc;EAAA,OAAMC,cAAc,CAAC,aAAD,EAAgB,IAAhB,CAApB;AAAA,CAApB;;AAKA,IAAMN,SAAS,GAAG,SAAZA,SAAY,CAACO,KAAD,EAAmB;EACjC,IAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;IAC3BC,OAAO,CAACC,IAAR,CAAaV,MAAM,CAACC,SAApB;IACA;EACH;;EACD,KAAK,IAAMU,GAAX,IAAkBH,KAAlB,EAAyB;IAAED,cAAc,CAACI,GAAD,EAAMH,KAAK,CAACG,GAAD,CAAX,CAAd;EAAkC;AAChE,CAND;;AAkBA,IAAMT,cAAc,GAAG,SAAjBA,cAAiB,CAACS,GAAD,EAAkC;EAAA,IAApBC,QAAoB,uEAAT,IAAS;;EACrD,IAAI,OAAOD,GAAP,KAAe,QAAnB,EAA6B;IACzBF,OAAO,CAACC,IAAR,CAAaV,MAAM,CAACE,cAApB;IACA,OAAO,IAAP;EACH;;EACD,0BAAeJ,SAAS,CAACe,QAAV,EAAf;EAAA,IAAQC,EAAR,uBAAQA,EAAR;;EACA,IAAMC,KAAK,GAAGhB,cAAc,CAACe,EAAD,EAAKH,GAAL,CAA5B;EACA,OAAOI,KAAK,IAAIH,QAAhB;AACH,CARD;;AAaA,IAAML,cAAc,GAAG,SAAjBA,cAAiB,CAACI,GAAD,EAAcH,KAAd,EAA6B;EAChDV,SAAS,CAACkB,QAAV,CAAmB;IAAEC,IAAI,EAAEN,GAAR;IAAaO,OAAO,EAAEV;EAAtB,CAAnB;AACH,CAFD;;AASA,IAAMZ,OAAO,GAAG,SAAVA,OAAU,CACZuB,gBADY,EAIX;EAAA,IAFDC,YAEC,uEAF6B,EAE7B;EAAA,IADDC,eACC,uEADyB,GACzB;;EAED,IAAI,OAAOF,gBAAP,KAA4B,WAAhC,EAA6C;IAAE,MAAMG,KAAK,CAACtB,MAAM,CAACG,cAAR,CAAX;EAAqC;;EAEpF,IAAMoB,aAAa,GAAG,SAAhBA,aAAgB,CAACC,MAAD;IAAA,0DAC8BL,gBAAgB,CAACM,IAD/C,oBACiED,MADjE;EAAA,CAAtB;;EAGA,IAAI,CAACE,KAAK,CAACC,OAAN,CAAcP,YAAd,CAAL,EAAkC;IAAE,MAAME,KAAK,CAACC,aAAa,CAACvB,MAAM,CAACI,iBAAR,CAAd,CAAX;EAAuD;;EAE3F,IAAMwB,UAAU,GAAGR,YAAY,CAACS,KAAb,CAAmB,UAAClB,GAAD;IAAA,OAAS,OAAOA,GAAP,KAAe,QAAxB;EAAA,CAAnB,CAAnB;;EACA,IAAI,CAACiB,UAAL,EAAiB;IACb,MAAMN,KAAK,CAACC,aAAa,CAACvB,MAAM,CAACK,mBAAR,CAAd,CAAX;EACH;;EACD,IAAMyB,eAAe,GAAG,SAAlBA,eAAkB,OAAY;IAAA,IAAThB,EAAS,QAATA,EAAS;IAChC,IAAMiB,cAAc,GAAG,EAAvB;;IACA,IAAIX,YAAY,CAACY,MAAb,KAAwB,CAA5B,EAA+B;MAC3B,KAAK,IAAMrB,GAAX,IAAkBG,EAAlB,EAAsB;QAClB,IAAIH,GAAG,KAAK,SAAZ,EAAuB;UAAEoB,cAAc,CAACpB,GAAD,CAAd,GAAsBG,EAAE,CAACH,GAAD,CAAxB;QAAgC;MAC5D;;MACD,OAAOoB,cAAP;IACH;;IACD,KAAK,IAAMpB,IAAX,IAAkBS,YAAlB,EAAgC;MAC5B,IAAMa,SAAS,GAAGtB,IAAG,CAACuB,QAAJ,CAAa,GAAb,CAAlB;;MACA,IAAMC,OAAO,GAAGF,SAAS,GAAGtB,IAAG,CAACyB,KAAJ,CAAU,GAAV,EAAeC,IAAf,CAAoBhB,eAApB,CAAH,GAA0CV,IAAnE;MACAoB,cAAc,CAACI,OAAD,CAAd,GAA0BpC,cAAc,CAACe,EAAD,EAAKH,IAAL,CAAxC;IACH;;IACD,OAAOoB,cAAP;EACH,CAdD;;EAeA,OAAOlC,QAAQ,CAACiC,eAAD,EAAkB,EAAlB,CAAR,CAA8BX,gBAA9B,CAAP;AACH,CAjCD;;AAoCA,SACIvB,OADJ,EAEIK,SAFJ,EAEeK,WAFf,EAGIC,cAHJ,EAGoBL,cAHpB"},"metadata":{},"sourceType":"module"}